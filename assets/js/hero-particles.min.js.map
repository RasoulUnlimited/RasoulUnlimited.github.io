{"version":3,"file":"hero-particles.min.js","names":["document","addEventListener","canvas","getElementById","ctx","getContext","particlesArray","resizeTimeout","width","window","innerWidth","height","innerHeight","clearTimeout","setTimeout","init","mouse","x","y","radius","event","Particle","constructor","directionX","directionY","size","color","this","draw","beginPath","arc","Math","PI","fillStyle","fill","update","dx","dy","sqrt","numberOfParticles","i","random","getComputedStyle","documentElement","getPropertyValue","trim","body","classList","contains","matchMedia","matches","push","cachedR","cachedG","cachedB","lastColorUpdateTime","isVisible","IntersectionObserver","entries","forEach","entry","isIntersecting","observe","animate","requestAnimationFrame","clearRect","length","now","Date","rgbaMatch","match","parseInt","updateParticleColorCache","opacityValue","maxDistanceSq","a","b","distance","strokeStyle","lineWidth","moveTo","lineTo","stroke","connect","MutationObserver","mutations","mutation","attributeName","attributes","heroImage","querySelector","heroSection","e","left","top","getBoundingClientRect","moveX","clientX","moveY","clientY","style","transform"],"sources":["hero-particles.js"],"mappings":"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","ignoreList":[],"sourcesContent":["document.addEventListener(\"DOMContentLoaded\", function () {\r\n  const canvas = document.getElementById(\"hero-particles\");\r\n  if (!canvas) {return;}\r\n\r\n  const ctx = canvas.getContext(\"2d\");\r\n  let particlesArray;\r\n\r\n  // Set canvas size\r\n  canvas.width = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n\r\n  // Handle resize with debounce\r\n  let resizeTimeout;\r\n  window.addEventListener(\"resize\", function () {\r\n    clearTimeout(resizeTimeout);\r\n    resizeTimeout = setTimeout(() => {\r\n      canvas.width = window.innerWidth;\r\n      canvas.height = window.innerHeight;\r\n      init();\r\n    }, 200);\r\n  });\r\n\r\n  // Mouse interaction\r\n  const mouse = {\r\n    x: null,\r\n    y: null,\r\n    radius: 150\r\n  };\r\n\r\n  window.addEventListener(\"mousemove\", function (event) {\r\n    mouse.x = event.x;\r\n    mouse.y = event.y;\r\n  });\r\n\r\n  // Particle class\r\n  class Particle {\r\n    constructor(x, y, directionX, directionY, size, color) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.directionX = directionX;\r\n      this.directionY = directionY;\r\n      this.size = size;\r\n      this.color = color;\r\n    }\r\n\r\n    // Method to draw individual particle\r\n    draw() {\r\n      ctx.beginPath();\r\n      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);\r\n      ctx.fillStyle = this.color;\r\n      ctx.fill();\r\n    }\r\n\r\n    // Check particle position, check mouse position, move the particle, draw the particle\r\n    update() {\r\n      // Check if particle is still within canvas\r\n      if (this.x > canvas.width || this.x < 0) {\r\n        this.directionX = -this.directionX;\r\n      }\r\n      if (this.y > canvas.height || this.y < 0) {\r\n        this.directionY = -this.directionY;\r\n      }\r\n\r\n      // Check collision detection - mouse position / particle position\r\n      const dx = mouse.x - this.x;\r\n      const dy = mouse.y - this.y;\r\n      const distance = Math.sqrt(dx*dx + dy*dy);\r\n      if (distance < mouse.radius + this.size){\r\n        if (mouse.x < this.x && this.x < canvas.width - this.size * 10) {\r\n          this.x += 10;\r\n        }\r\n        if (mouse.x > this.x && this.x > this.size * 10) {\r\n          this.x -= 10;\r\n        }\r\n        if (mouse.y < this.y && this.y < canvas.height - this.size * 10) {\r\n          this.y += 10;\r\n        }\r\n        if (mouse.y > this.y && this.y > this.size * 10) {\r\n          this.y -= 10;\r\n        }\r\n      }\r\n\r\n      // Move particle\r\n      this.x += this.directionX;\r\n      this.y += this.directionY;\r\n\r\n      // Draw particle\r\n      this.draw();\r\n    }\r\n  }\r\n\r\n  // Create particle array\r\n  function init() {\r\n    particlesArray = [];\r\n    const numberOfParticles = (canvas.height * canvas.width) / 9000;\r\n    for (let i = 0; i < numberOfParticles; i++) {\r\n      const size = (Math.random() * 5) + 1;\r\n      const x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);\r\n      const y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);\r\n      const directionX = (Math.random() * 2) - 1; // -1 to 1\r\n      const directionY = (Math.random() * 2) - 1; // -1 to 1\r\n\r\n      // Theme aware colors\r\n      let color = getComputedStyle(document.documentElement).getPropertyValue(\"--particle-color\").trim() || \"rgba(100, 100, 100, 0.2)\";\r\n\r\n      // Check if we can detect theme from body class or computed style\r\n      // This is a simple check, might need adjustment based on actual theme implementation\r\n      const isDark = document.body.classList.contains(\"dark-mode\") ||\r\n                           window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\r\n\r\n      if (isDark) {\r\n        color = \"rgba(255, 255, 255, 0.2)\";\r\n      } else {\r\n        color = \"rgba(0, 0, 0, 0.2)\";\r\n      }\r\n\r\n      particlesArray.push(new Particle(x, y, directionX, directionY, size, color));\r\n    }\r\n  }\r\n\r\n  // Cache computed particle color to avoid repeated getComputedStyle calls\r\n  let cachedR = 99, cachedG = 102, cachedB = 241; // Default Indigo\r\n  let lastColorUpdateTime = 0;\r\n  const COLOR_CACHE_INTERVAL = 1000; // Update color cache every 1 second\r\n\r\n  function updateParticleColorCache() {\r\n    const now = Date.now();\r\n    if (now - lastColorUpdateTime < COLOR_CACHE_INTERVAL) {return;}\r\n\r\n    lastColorUpdateTime = now;\r\n    const style = getComputedStyle(document.documentElement);\r\n    const particleColor = style.getPropertyValue(\"--particle-color\").trim() || \"rgba(99, 102, 241, 0.2)\";\r\n\r\n    // Parse RGBA color once per interval\r\n    const rgbaMatch = particleColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/);\r\n    if (rgbaMatch) {\r\n      cachedR = parseInt(rgbaMatch[1], 10);\r\n      cachedG = parseInt(rgbaMatch[2], 10);\r\n      cachedB = parseInt(rgbaMatch[3], 10);\r\n    }\r\n  }\r\n\r\n  // Animation loop\r\n  let isVisible = true;\r\n  if (\"IntersectionObserver\" in window) {\r\n    const observer = new IntersectionObserver((entries) => {\r\n      entries.forEach(entry => {\r\n        isVisible = entry.isIntersecting;\r\n      });\r\n    });\r\n    observer.observe(canvas);\r\n  }\r\n\r\n  function animate() {\r\n    requestAnimationFrame(animate);\r\n    if (!isVisible) {return;}\r\n\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    for (let i = 0; i < particlesArray.length; i++) {\r\n      particlesArray[i].update();\r\n    }\r\n    connect();\r\n  }\r\n\r\n  // Check if particles are close enough to draw line between them\r\n  function connect() {\r\n    updateParticleColorCache();\r\n\r\n    let opacityValue = 1;\r\n    const maxDistanceSq = (canvas.width/7) * (canvas.height/7);\r\n\r\n    for (let a = 0; a < particlesArray.length; a++) {\r\n      for (let b = a + 1; b < particlesArray.length; b++) {\r\n        const distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x))\r\n                + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));\r\n\r\n        if (distance < maxDistanceSq) {\r\n          opacityValue = 1 - (distance/20000);\r\n          ctx.strokeStyle = `rgba(${cachedR}, ${cachedG}, ${cachedB}, ${opacityValue})`;\r\n          ctx.lineWidth = 1;\r\n          ctx.beginPath();\r\n          ctx.moveTo(particlesArray[a].x, particlesArray[a].y);\r\n          ctx.lineTo(particlesArray[b].x, particlesArray[b].y);\r\n          ctx.stroke();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  init();\r\n  animate();\r\n\r\n  // Re-init on theme change if possible\r\n  // Assuming there is a theme toggle that might trigger a class change or event\r\n  const observer = new MutationObserver(function (mutations) {\r\n    mutations.forEach(function (mutation) {\r\n      if (mutation.attributeName === \"class\") {\r\n        init();\r\n      }\r\n    });\r\n  });\r\n  observer.observe(document.body, { attributes: true });\r\n});\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", function () {\r\n  // Hero Image Tilt Effect\r\n  const heroImage = document.querySelector(\".profile-image\");\r\n  const heroSection = document.getElementById(\"hero\");\r\n\r\n  if (heroImage && heroSection) {\r\n    heroSection.addEventListener(\"mousemove\", function (e) {\r\n      const { left, top, width, height } = heroSection.getBoundingClientRect();\r\n      const x = (e.clientX - left) / width;\r\n      const y = (e.clientY - top) / height;\r\n\r\n      const moveX = (x - 0.5) * 15;\r\n      const moveY = (y - 0.5) * 15;\r\n\r\n      heroImage.style.transform = `perspective(1000px) rotateY(${moveX}deg) rotateX(${-moveY}deg) scale(1.05)`;\r\n    });\r\n\r\n    heroSection.addEventListener(\"mouseleave\", function () {\r\n      heroImage.style.transform = \"perspective(1000px) rotateY(0) rotateX(0) scale(1)\";\r\n    });\r\n  }\r\n});\r\n"]}